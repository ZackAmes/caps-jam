type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type u8 = u8 [storable: true, drop: true, dup: true, zero_sized: false];
type test_input::test_input::Vec2 = Struct<ut@test_input::test_input::Vec2, u8, u8> [storable: true, drop: true, dup: true, zero_sized: false];
type test_input::test_input::Location = Enum<ut@test_input::test_input::Location, Unit, test_input::test_input::Vec2, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type Tuple<u8, u8, u8, u8, u8> = Struct<ut@Tuple, u8, u8, u8, u8, u8> [storable: true, drop: true, dup: true, zero_sized: false];
type test_input::test_input::ActionType = Enum<ut@test_input::test_input::ActionType, test_input::test_input::Vec2, test_input::test_input::Vec2> [storable: true, drop: true, dup: true, zero_sized: false];
type Const<u8, 2> = Const<u8, 2> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<u8, 1> = Const<u8, 1> [storable: false, drop: false, dup: false, zero_sized: false];
type Const<u8, 0> = Const<u8, 0> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc enum_match<test_input::test_input::Location> = enum_match<test_input::test_input::Location>;
libfunc branch_align = branch_align;
libfunc drop<Unit> = drop<Unit>;
libfunc const_as_immediate<Const<u8, 0>> = const_as_immediate<Const<u8, 0>>;
libfunc store_temp<u8> = store_temp<u8>;
libfunc jump = jump;
libfunc const_as_immediate<Const<u8, 1>> = const_as_immediate<Const<u8, 1>>;
libfunc struct_deconstruct<test_input::test_input::Vec2> = struct_deconstruct<test_input::test_input::Vec2>;
libfunc const_as_immediate<Const<u8, 2>> = const_as_immediate<Const<u8, 2>>;
libfunc enum_match<test_input::test_input::ActionType> = enum_match<test_input::test_input::ActionType>;
libfunc drop<u8> = drop<u8>;
libfunc struct_construct<Tuple<u8, u8, u8, u8, u8>> = struct_construct<Tuple<u8, u8, u8, u8, u8>>;
libfunc store_temp<Tuple<u8, u8, u8, u8, u8>> = store_temp<Tuple<u8, u8, u8, u8, u8>>;

F0:
enum_match<test_input::test_input::Location>([0]) { fallthrough([2]) F0_B0([3]) F0_B1([4]) };
branch_align() -> ();
drop<Unit>([2]) -> ();
const_as_immediate<Const<u8, 0>>() -> ([5]);
const_as_immediate<Const<u8, 0>>() -> ([6]);
const_as_immediate<Const<u8, 0>>() -> ([7]);
store_temp<u8>([5]) -> ([8]);
store_temp<u8>([6]) -> ([9]);
store_temp<u8>([7]) -> ([10]);
jump() { F0_B2() };
F0_B0:
branch_align() -> ();
const_as_immediate<Const<u8, 1>>() -> ([11]);
struct_deconstruct<test_input::test_input::Vec2>([3]) -> ([12], [13]);
store_temp<u8>([11]) -> ([8]);
store_temp<u8>([12]) -> ([9]);
store_temp<u8>([13]) -> ([10]);
jump() { F0_B2() };
F0_B1:
branch_align() -> ();
drop<Unit>([4]) -> ();
const_as_immediate<Const<u8, 2>>() -> ([14]);
const_as_immediate<Const<u8, 0>>() -> ([15]);
const_as_immediate<Const<u8, 0>>() -> ([16]);
store_temp<u8>([14]) -> ([8]);
store_temp<u8>([15]) -> ([9]);
store_temp<u8>([16]) -> ([10]);
F0_B2:
enum_match<test_input::test_input::ActionType>([1]) { fallthrough([17]) F0_B3([18]) };
branch_align() -> ();
const_as_immediate<Const<u8, 0>>() -> ([19]);
struct_deconstruct<test_input::test_input::Vec2>([17]) -> ([20], [21]);
drop<u8>([21]) -> ();
store_temp<u8>([19]) -> ([22]);
store_temp<u8>([20]) -> ([23]);
jump() { F0_B4() };
F0_B3:
branch_align() -> ();
const_as_immediate<Const<u8, 1>>() -> ([24]);
struct_deconstruct<test_input::test_input::Vec2>([18]) -> ([25], [26]);
drop<u8>([26]) -> ();
store_temp<u8>([24]) -> ([22]);
store_temp<u8>([25]) -> ([23]);
F0_B4:
struct_construct<Tuple<u8, u8, u8, u8, u8>>([8], [9], [10], [22], [23]) -> ([27]);
store_temp<Tuple<u8, u8, u8, u8, u8>>([27]) -> ([27]);
return([27]);

test_input::test_input::main@F0([0]: test_input::test_input::Location, [1]: test_input::test_input::ActionType) -> (Tuple<u8, u8, u8, u8, u8>);
